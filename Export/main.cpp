// Export/main.cpp

// Base
#include <epicsVersion.h>
// Tools
#include <AutoPtr.h>
#include <BinaryTree.h>
#include <RegularExpression.h>
#include <epicsTimeHelper.h>
#include <ArgParser.h>
// Storage
#include <SpreadsheetReader.h>
#include <AutoIndex.h>

#undef DEBUG_EXPORT

// Globals that are set from the command-line,
// see initial section of main().
static int precision;
static RawValue::NumberFormat format = RawValue::DEFAULT;
static bool verbose;
static bool only_millisecs;

static void format_time(const epicsTime &time, stdString &text)
{
    if (only_millisecs)
    {
        epicsTimeStamp stamp = time;
        stamp.nsec = ((stamp.nsec + 500000) / 1000000) * 1000000;
        epicsTime2string(epicsTime(stamp), text);
        text = text.substr(0, 23);
        return;
    }
    epicsTime2string(time, text);
}


// Visitor for BinaryTree of channel names;
// see get_names_for_pattern().
static void add_name2vector(const stdString &name, void *arg)
{
    stdVector<stdString> *names = (stdVector<stdString> *)arg;
    if (verbose)
        printf("%s\n", name.c_str());
    names->push_back(name);
}

// Iterate over names in index, fetch those
// that match the pattern.
void get_names_for_pattern(Index &index,
                           stdVector<stdString> &names,
                           const stdString &pattern)
{
    if (verbose)
        printf("Expanding pattern '%s'\n", pattern.c_str());
    try
    {
        AutoPtr<RegularExpression> regex;
        if (pattern.length() > 0)
            regex.assign(new RegularExpression(pattern.c_str()));
        Index::NameIterator name_iter;
        if (!index.getFirstChannel(name_iter))
            return; // No names
        // Put all names in binary tree
        BinaryTree<stdString> channels;
        do
        {
            if (regex && !regex->doesMatch(name_iter.getName()))
                continue; // skip what doesn't match regex
            channels.add(name_iter.getName());
        }
        while (index.getNextChannel(name_iter));
        // Sorted dump of names
        channels.traverse(add_name2vector, (void *)&names);
    }
    catch (GenericException &e)
    {
        throw GenericException(__FILE__, __LINE__,
                               "Error expanding name pattern '%s':\n%s\n",
                               pattern.c_str(), e.what());
    }
}

// List channel names, maybe with start/end info.
void list_channels(Index &index, stdVector<stdString> names, bool info)
{
    epicsTime start, end;
    stdString s, e;
    AutoPtr<RTree> tree;
    size_t i;
    for (i=0; i<names.size(); ++i)
    {
        if (info)
        {
            stdString directory;
            tree = index.getTree(names[i], directory);
            if (!tree)
                throw GenericException(__FILE__, __LINE__,
                                       "Cannot locate channel '%s'",
                                       names[i].c_str());
            tree->getInterval(start, end);
            printf("%s\t%s\t%s\n", names[i].c_str(),
                   epicsTimeTxt(start, s), epicsTimeTxt(end, e));
        }
        else
            printf("%s\n", names[i].c_str());
    }
}

// Create gnuplot output.
// output_name: Use for data and "..plt" command file.
// image: slightly different command file for image creation.
void dump_gnuplot(Index &index,
                  stdVector<stdString> names,
                  epicsTime *start, epicsTime *end,
                  ReaderFactory::How how, double delta,
                  stdString output_name,
                  bool image)
{
    stdVector<stdString> units;
    size_t i, e;
    stdString time, stat, val;
    const RawValue::Data *value;
    bool prev_line_was_data;
    bool is_array = false;
    
    // GNUPlot data file....
    AutoFilePtr f(output_name.c_str(), "wt");
    if (! f)
        throw GenericException(__FILE__, __LINE__,
                               "Cannot open %s\n", output_name.c_str());
    fprintf(f, "# Generated by ArchiveExport " ARCH_VERSION_TXT "\n");
    fprintf(f, "# Method: %s\n", ReaderFactory::toString(how, delta));
    // Data is dumped channel by channel, not in spreadsheet form.
    for (i=0; i<names.size(); ++i)
    {
        fprintf(f, "# Channel '%s'\n", names[i].c_str());
        prev_line_was_data = false;
        AutoPtr<DataReader> reader(ReaderFactory::create(index, how, delta));
        value = reader->find(names[i], start);
        if (value)
        {   // Get units.
            units.push_back(reader->getInfo().getUnits());
            // Check if it's an array; can only plot arrays on their own.
            if (reader->getCount() > 1)
            {
                is_array = true;
                if (names.size() > 0)
                    throw GenericException(__FILE__, __LINE__,
                                           "Array channel '%s' cannot be "
                                           "combined with other channels",
                                           names[i].c_str());
            }
        }
        else
            units.push_back("-no data-");

        while (value)
        {
            if (end && RawValue::getTime(value) >= *end)
                break;
            format_time(RawValue::getTime(value), time);
            RawValue::getStatus(value, stat);            
            if (RawValue::isInfo(value))
            {   // Add one(!) empty line for break in data
                if (prev_line_was_data)
                    fprintf(f, "\n");
                fprintf(f, "# %s %s\n", time.c_str(), stat.c_str());
                prev_line_was_data = false;
            }
            else
            {
                if (reader->getCount() <= 1)
                {   // Scalar
                    if (reader->getType() == DBR_TIME_ENUM)
                    {   // Enum: Show number, not the string, for plotting
                        long l;
                        RawValue::getLong(reader->getType(),
                                          reader->getCount(),
                                          value, l, 0);
                        fprintf(f, "%s\t%ld\t%s\n",
                                time.c_str(), l, stat.c_str());
                    }
                    else
                    {
                        RawValue::getValueString(
                            val, reader->getType(), reader->getCount(),
                            value, &reader->getInfo(), format, precision); 
                        fprintf(f, "%s\t%s\t%s\n",
                                time.c_str(), val.c_str(), stat.c_str());
                    }   
                }
                else
                {   // Array
                    double dbl;
                    for (e=0; e<reader->getCount(); ++e)
                    {
                        RawValue::getDouble(reader->getType(),
                                            reader->getCount(),
                                            value, dbl, e);
                        fprintf(f, "%s\t%zu\t%g\n", time.c_str(), e, dbl);
                    }
                    fprintf(f, "\n");
                }
                prev_line_was_data = true;
            }
            value = reader->next();
        }
        fprintf(f, "\n\n"); // GNUPlot index separator
    }
    f.close();

    // Generate command file for GNUPlot
    stdString cmd_name = output_name;
    cmd_name += ".plt";
    if (!f.open(cmd_name.c_str(), "wt"))
        fprintf(stderr, "Cannot create %s\n",
                cmd_name.c_str());
    fprintf(f, "# GNUPlot command file for data in\n");
    fprintf(f, "# the file '%s'\n", output_name.c_str());
    fprintf(f, "# Generated by ArchiveExport " ARCH_VERSION_TXT "\n");
    fprintf(f, "\n");
    fprintf(f, "set data style steps\n");   
    fprintf(f, "set timefmt \"%%m/%%d/%%Y %%H:%%M:%%S\"\n");    
    fprintf(f, "set xdata time\n");
    fprintf(f, "set xlabel \"Time\"\n");
    if (is_array)
        fprintf(f, "set format x \"%%m/%%d/%%Y %%H:%%M:%%S\"\n");
    else
        fprintf(f, "set format x \"%%m/%%d/%%Y\\n%%H:%%M:%%S\"\n");
    fprintf(f, "set ylabel \"Data\"\n");
    fprintf(f, "set grid\n");
    fprintf(f, "# X axis tick control:\n");
    fprintf(f, "# One tick per day:\n");
    fprintf(f, "# set xtics 86400\n");
    fprintf(f, "# Two tick per day:\n");
    fprintf(f, "# set xtics 43200\n");
    fprintf(f, "# One tick per hour:\n");
    fprintf(f, "# set xtics 3600\n");
    fprintf(f, "set mxtics 2\n");
    bool second_y_axis = names.size() == 2;
    if (second_y_axis)
    {
        fprintf(f, "# When using 2 channels:\n");
        fprintf(f, "set ylabel '%s'\n", names[0].c_str());
        fprintf(f, "set y2label '%s'\n", names[1].c_str());
        fprintf(f, "set y2tics\n");
    }    
    if (image)
    {
        fprintf(f, "set terminal png small color "
                "xfffcce x000040 xd1cfad\n");
        fprintf(f, "set output '%s.png'\n",
                output_name.c_str());
    }
    if (is_array)
    {
        fprintf(f, "set view 120, 100, 1\n");
        fprintf(f, "#set contour\n");
        fprintf(f, "set surface\n");
        fprintf(f, "#set hidden3d\n");
        fprintf(f, "splot '%s' using 1:3:4",
                output_name.c_str());
        fprintf(f, " title '%s' with lines\n",
                names[0].c_str());
    }
    else
    {
        fprintf(f, "plot '%s' index 0 using 1:3 title '%s [%s]'",
                output_name.c_str(),
                names[0].c_str(), units[0].c_str());
        for (i=1; i<names.size(); ++i)
            fprintf(f, ", '%s' index %zu using 1:3 %s title '%s [%s]'",
                    output_name.c_str(), i,
                    ((second_y_axis && i==1) ? "axes x1y2" : ""),
                    names[i].c_str(), units[i].c_str());
    }
    fprintf(f, "\n");
}

// Create text file with spread-sheet formatted data.
void dump_spreadsheet(Index &index,
                      stdVector<stdString> names,
                      epicsTime *start, epicsTime *end,
                      bool raw_time,
                      bool status_text,
                      ReaderFactory::How how, double delta,
                      stdString output_name)
{
    SpreadsheetReader sheet(index, how, delta);
    bool ok = sheet.find(names, start);
    size_t i;
    stdString time, stat, val;
    const RawValue::Data *value;
    FILE *f = stdout;
    AutoFilePtr file;
    if (output_name.length() > 0)
    {
        file.open(output_name.c_str(), "wt");
        if (file)
            f = file;
        else
            throw GenericException(__FILE__, __LINE__,
                                   "Cannot open %s", output_name.c_str());
    }
    fprintf(f, "# Generated by ArchiveExport " ARCH_VERSION_TXT "\n");
    fprintf(f, "# Method: %s\n", ReaderFactory::toString(how, delta));
    fprintf(f, "\n");
    fprintf(f, "# Time                       ");
    if (raw_time)
        fprintf(f, "\tsecs");
    for (i=0; i<sheet.getNum(); ++i)
    {
        if (sheet.found(i))
            fprintf(f, "\t%s [%s]",
                    sheet.getName(i).c_str(),
                    sheet.getInfo(i).getUnits());
        else
            fprintf(f, "\t%s - NOT FOUND",
                    sheet.getName(i).c_str());
        if (status_text)
            fprintf(f, "\t");
    }
    fprintf(f, "\n");
    while (ok)
    {
        if (end && sheet.getTime() >= *end)
            break;
        // '03/23/2004 10:48:48.032899334'
        format_time(sheet.getTime(), time);
        fprintf(f, "%s", time.c_str());
        if (raw_time)
        {
            epicsTimeStamp stamp = sheet.getTime();
            fprintf(f, "\t%lu", (unsigned long)stamp.secPastEpoch);
        }
        for (i=0; i<sheet.getNum(); ++i)
        {
            value = sheet.get(i);
            if (value)
            {
                RawValue::getStatus(value, stat);
                if (RawValue::isInfo(value))
                {
                    fprintf(f, "\t#N/A");
                    if (status_text)
                        fprintf(f, "\t%s", stat.c_str());
                }
                else
                {
                    RawValue::getValueString(
                        val, sheet.getType(i), sheet.getCount(i),
                        value, &sheet.getInfo(i), format, precision);
                    fprintf(f, "\t%s", val.c_str());
                    if (status_text)
                        fprintf(f, "\t%s", stat.c_str());
                }
            }
            else
            {
                fprintf(f, "\t#N/A");
                if (status_text)
                    fprintf(f, "\t<no data>");
            }
        }
        fprintf(f, "\n");
        ok = sheet.next();
    }
}

int main(int argc, const char *argv[])
{
    try
    {
        CmdArgParser parser(argc, argv);
        parser.setHeader("Archive Export version " ARCH_VERSION_TXT ", "
                         EPICS_VERSION_STRING
                         ", built " __DATE__ ", " __TIME__ "\n\n");
        parser.setArgumentsInfo("<index file> {channel}");
        CmdArgFlag   be_verbose (parser, "verbose", "Verbose mode");
        CmdArgString pattern    (parser, "match", "<reg. exp.>",
                                 "Channel name pattern");
        CmdArgFlag   do_list    (parser, "list", "List all channels");
        CmdArgFlag   do_info    (parser, "info", "Time-range info on channels");
        CmdArgString start_time (parser, "start", "<time>",
                                 "Format: \"mm/dd/yyyy[ hh:mm:ss[.nano-secs]]\"");
        CmdArgString end_time   (parser, "end", "<time>", "(exclusive)");
        CmdArgFlag   status_text(parser, "text",
                                 "Include text column for status/severity (default)");
        CmdArgFlag   no_status_text(parser, "no_text",
                                 "Exclude text column for status/severity");
        CmdArgString output     (parser,
                                 "output", "<file>", "Output to file");
        CmdArgDouble plotbin    (parser,
                                 "plotbin", "<seconds>",
                                 "Bin the raw data for plotting");
        CmdArgDouble average    (parser,
                                 "average", "<seconds>", "average values");
        CmdArgDouble linear     (parser,
                                 "linear", "<seconds>",
                                 "Interpolate values linearly");
        CmdArgString format_txt (parser,
                                 "format", "<decimal|engineering|exponential>",
                                 "Use specific format for numbers");
        CmdArgInt    prec       (parser,
                                 "precision", "<int>", "Precision of numbers");
        CmdArgFlag   GNUPlot    (parser,
                                 "gnuplot", "Generate GNUPlot command file");
        CmdArgFlag   image      (parser,
                                 "Gnuplot", "Generate GNUPlot output for Image");
        CmdArgFlag   raw_time   (parser, "raw_time",
                                 "Include columns for EPICS time stamp");
        CmdArgFlag   millisecs  (parser, "millisecs",
                                 "Truncate time to millisecs in spreadsheet dump.");
        // defaults
        prec.set(-1);
        if (! parser.parse())
            return -1;
        if (parser.getArguments().size() < 1)
        {
            parser.usage();
            return -1;
        }
        precision = prec;
        if (!strncmp(format_txt.get().c_str(), "d", 1))
            format = RawValue::DECIMAL;
        else if (!strncmp(format_txt.get().c_str(), "en", 2))
            format = RawValue::ENGINEERING;
        else if (!strncmp(format_txt.get().c_str(), "ex", 2))
            format = RawValue::EXPONENTIAL;
        else if (format_txt.get().length() > 0)
        {
            fprintf(stderr, "Unknown format string '%s'\n", format_txt.get().c_str());
            return -1;
        }   
        verbose = be_verbose;
        only_millisecs = millisecs;
        // Start/end time
        AutoPtr<epicsTime> start, end;
        stdString txt;
        if (start_time.get().length() > 0)
        {
            start = new epicsTime;
            if (!string2epicsTime(start_time.get(), *start))
            {
                fprintf(stderr, "Parse error for start time '%s'\n",
                        start_time.get().c_str());
                start = 0;
                parser.usage();
                return -1;
            }
            if (verbose)
                printf("Using start time %s\n", epicsTimeTxt(*start, txt));
        }
        if (end_time.get().length() > 0)
        {
            end = new epicsTime();
            if (!string2epicsTime(end_time.get(), *end))
            {
                fprintf(stderr, "Parse error for end time '%s'\n",
                        end_time.get().c_str());
                end = 0;
                parser.usage();
                return -1;
            }
            if (verbose)
                printf("Using end time   %s\n", epicsTimeTxt(*end, txt));
        }
        if (start && end && *start > *end)
        {   // Could simply swap start and end, but assume the user is
            // confused and should rethink the request.
            fprintf(stderr, "start time is greater than end time.\n");
            return -1;
        }
  
        // Index name
        stdString index_name = parser.getArgument(0);
        // Channel names
        stdVector<stdString> names;
        if (parser.getArguments().size() > 1)
        {
            if (! pattern.get().empty())
            {
                fputs("Pattern from '-m' switch is ignored\n"
                      "since a list of channels was also provided.\n", stderr);
            }
            // first argument was directory file name, skip that:
            for (size_t i=1; i<parser.getArguments().size(); ++i)
                names.push_back(parser.getArgument(i));
        }
        if ((GNUPlot || image) && output.get().length() == 0)
        {
    
            fprintf(stderr, "The -gnuplot/Gnuplot options require "
                    "an -output file\n");
            return -1;    
        }
        // How?
        ReaderFactory::How how = ReaderFactory::Raw;
        double delta = 0.0;
        if (double(plotbin) > 0.0)
        {
            how = ReaderFactory::Plotbin;
            delta = double(plotbin);
        }
        else if (double(average) > 0.0)
        {
            how = ReaderFactory::Average;
            delta = double(average);
        }
        else if (double(linear) > 0.0)
        {
            how = ReaderFactory::Linear;
            delta = double(linear);
        }
        // Open index
        AutoIndex index;
        index.open(index_name.c_str());
        if (verbose)
            printf("Opened index '%s'\n", index_name.c_str());
        if (do_info  &&  names.size()<=0  &&  pattern.get().length()<=0)
            do_list.set(); // otherwise it'd be a NOP
        if (names.size() <= 0 &&
            (do_list  ||  pattern.get().length() > 0))
            get_names_for_pattern(index, names, pattern);
        if (do_info)
            list_channels(index, names, true);
        else if (do_list)
            list_channels(index, names, false);
        else if (names.size() > 0)
        {
            if (GNUPlot || image)
                dump_gnuplot(index, names, start, end,
                             how, delta, output, image);
            else
                dump_spreadsheet(index, names, start, end,
                                 raw_time, !no_status_text, how, delta,
                                 output);
        }
        index.close();
    }
    catch (GenericException &e)
    {
        fprintf(stderr, "Error:\n%s\n", e.what());
        return -1;
    } 
    return 0;
}

